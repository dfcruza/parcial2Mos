function todo = Punto3Parcial()

    function puntoInterseccion = interseccion(a1, b1, a2, b2)

        A = [a1; a2];
        B = [b1; b2];
        puntoInterseccion = A\B;

    end

    %Primera constraint: 2x1 + x2 <= 100
    a1 = [2,1];
    b1 = [100];

    %Constraint 2: x1 + x2 <= 80
    a2 = [1,1];
    b2 = [80];

    %Constraint 3: x1 <= 40
    a3 = [1,0];
    b3 = [40];

    %Constraint 4: x2 >= 0
    a4 = [0, -1];
    b4 = [0];

    vertices = [0 0; 0 b2(1); 40 0];
    intersecciones = [];

    intersecciones = [intersecciones, interseccion(a1, b1 , a2, b2)];
    intersecciones = [intersecciones, interseccion(a1, b1 , a3, b3)];
    intersecciones = [intersecciones, interseccion(a1, b1 , a4, b4)];
    intersecciones = [intersecciones, interseccion(a2, b2 , a3, b3)];
    intersecciones = [intersecciones, interseccion(a2, b2 , a4, b4)];
    
    interseccionesViables = [];

    for punto = intersecciones
        if all(a1 .* punto' <= b1) && all(a2 .* punto' <= b2) && all(a3 .* punto' <= b3) && all(a4 .* punto' <= b4)
            interseccionesViables = [interseccionesViables, punto];
        end
    end
    interseccionesViables = interseccionesViables.'
    disp('Vertices:');
    disp(vertices);
    disp('Puntos de interseccion:');
    disp(interseccionesViables);

    % Plotea restricciones, vértices y puntos de intersección

    % Restricción 1: 2x1 + x2 <= 100
    x = linspace(-10, 100, 1000);
    y1 = 100 - 2 * x;

    % Restricción 2: x1 + x2 <= 80
    y2 = 80 - x;

    % Plotear restricciones
    figure;
    plot(x, y1, 'LineWidth', 2, 'DisplayName', '2x_1 + x_2 \leq 100');
    hold on;
    plot(x, y2, 'LineWidth', 2, 'DisplayName', 'x_1 + x_2 \leq 80');

    % Plotear restricciones verticales y horizontales con línea punteada
    plot([40, 40], [-10, 100], '--', 'LineWidth', 2, 'DisplayName', 'x_1 \leq 40');
    plot([-10, 100], [0, 0], '--', 'LineWidth', 2, 'DisplayName', 'x_2 \geq 0');
    plot([0, 0], [-10, 100], '--', 'LineWidth', 2, 'DisplayName', 'x_1 \geq 0');

    % Plotear vértices y etiquetar sus coordenadas
    plot(vertices(:, 1), vertices(:, 2), 'bo', 'MarkerSize', 10, 'DisplayName', 'Vertices');
    for i = 1:size(vertices, 1)
        text(vertices(i, 1), vertices(i, 2), ['(' num2str(vertices(i, 1)) ', ' num2str(vertices(i, 2)) ')'], 'FontSize', 10);
    end

    % Plotear puntos de intersección y etiquetar sus coordenadas
    plot(interseccionesViables(:, 1), interseccionesViables(:, 2), 'ro', 'MarkerSize', 10, 'DisplayName', 'Puntos de interseccion');
    for i = 1:size(interseccionesViables, 1)
        text(interseccionesViables(i, 1), interseccionesViables(i, 2), ['(' num2str(interseccionesViables(i, 1)) ', ' num2str(interseccionesViables(i, 2)) ')'], 'FontSize', 10);
    end

    vertices = [vertices; interseccionesViables];

    adyacentes = containers.Map();

    adyacentes(mat2str(vertices(1, :))) = {vertices(2, :), vertices(3, :)};
    adyacentes(mat2str(vertices(2, :))) = {vertices(1, :), vertices(4, :)};
    adyacentes(mat2str(vertices(3, :))) = {vertices(1, :), vertices(5, :)};
    adyacentes(mat2str(vertices(4, :))) = {vertices(2, :), vertices(5, :)};
    adyacentes(mat2str(vertices(5, :))) = {vertices(3, :), vertices(4, :)};


    valores = containers.Map();
    for i = 1:size(vertices, 1)
        stringVertice = mat2str(vertices(i, :));
        %Calculamos los valores de la función objetivo
        %3*x1 + 2*x2
        valores(stringVertice) = 3 * vertices(i, 1) + 2 * vertices(i, 2);
    end

    %Vamos a empezar en un vértice aleatorio
    FEV_str = mat2str(vertices(randi(size(vertices, 1)), :));
    %disp("FEV_str:")
    %disp(FEV_str)
    %disp("Valores de FEV")
    %disp(valores(FEV_str))
    %disp("Adyacencias de FEV")
    %disp(adyacentes(FEV_str))
    maxVal = 0;
    maxVertex_str = '';

    while true
        % Buscamos el vértice adyacente que tiene mayor valor de la función
        % objetivo
        for vertex = adyacentes(FEV_str)
            if valores(mat2str(vertex{1})) > maxVal
                maxVal = valores(mat2str(vertex{1}));
                maxVertex_str = mat2str(vertex{1});
            end
        end

        % Si el vértice actual es el más óptimo, ya terminamos
        disp("Maxvertex str")
        disp(maxVertex_str)
        disp("FEV str")
        disp(FEV_str)
        if maxVertex_str == FEV_str
            return;
        end

        % Si no, actualizar el vértice actual y FEV
        FEV_str = maxVertex_str;
    end

    

end